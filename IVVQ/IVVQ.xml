<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://www.oasis-open.org/docbook/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    version="5.0">
    <info>
        <title>Support du cours "Intégration Vérification Validation Qualification"</title>
        <author>
            <personname>Franck Silvestre</personname>
            <email>franck.silvestre@irit.fr</email>
        </author>
        <keywordset>
            <keyword>ingénierie système</keyword>
            <keyword>vérification</keyword>
            <keyword>validation</keyword>
            <keyword>intégration</keyword>
            <keyword>qualification</keyword>
            <keyword role="hashtag">ivvq</keyword>
        </keywordset>
        <legalnotice><para><link xlink:href="http://creativecommons.org/licenses/by-nc/3.0/">Cette oeuvre est mise à disposition selon les termes de la Licence Creative Commons Paternité - Pas d'Utilisation Commerciale 3.0 non transposé.</link></para></legalnotice>
    </info>
    <section>
        <title>01 - Définitions</title>
        <section role="slide" xml:id="ivvq_s1">
            <title>Qu'est ce qu'un système ?</title>
            <para>Un système est une solution économique et performante répondant aux besoins d’un
                client tout en satisfaisant l’ensemble des parties prenantes.</para>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    La définition proposée est issue du contexte de l'Ingénierie Système.
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s2">
            <title>Exemples</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Une voiture</para>
                    </listitem>
                    <listitem>
                        <para>Un satellite</para>
                    </listitem>
                    <listitem>
                        <para>Un progiciel de gestion intégré</para>
                    </listitem>
                    <listitem>
                        <para>Un Environnement Numérique de Travail</para>
                    </listitem>
                </itemizedlist>
            </para>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    En Ingénierie Système, un système est souvent un dispositif associant à la fois du matériel et du logiciel.
                    Dans le cadre de cet enseignement, nous étudierons plus particulièrement les systèmes correspondant à des logiciels complexes.
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s3">
            <title>Caractéristiques d'un système</title>
            <para>
                <itemizedlist>

                    <listitem>
                        <para>Multi-fontionnel</para>
                    </listitem>
                    <listitem>
                        <para>Complexe</para>
                    </listitem>
                    <listitem>
                        <para>Assemblage de plusieurs constituants eux mêmes pouvant être des
                            systèmes</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s4">
            <title>Vue arborescente d'un système</title>
            <para>
                <mediaobject>
                    <alt>Vue arborescente d'un système</alt>
                    <imageobject>
                        <imagedata fileref="images/01_VueArborescenteSysteme.png"/>
                    </imageobject>

                </mediaobject>
            </para>
            <note>
                <para>Dans la suite du document nous désignerons un constituant d'un système par
                    l'une des expressions suivantes : "sous-système", "composant". </para>
            </note>
        </section>
        <section role="slide" xml:id="ivvq_s5">
            <title>La vérification</title>
            <para>Vérifier un système ou un constituant du système, c’est s’assurer qu’il est
                conforme à ses spécifications techniques. <mediaobject>
                    <alt>Composant vérifié</alt>
                    <imageobject>
                        <imagedata fileref="images/02_Verification.png"/>
                    </imageobject>
                </mediaobject>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s6">
            <title>La vérification est elle suffisante ?</title>
            <para> Est ce que mon composant vérifié fonctionne toujours lorsqu’il est intégré ? <mediaobject>
                    <alt>Composant vérifié</alt>
                    <imageobject>
                        <imagedata fileref="images/03_Validation_interrogation.png"/>
                    </imageobject>
                </mediaobject>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s7">
            <title>La validation</title>
            <para>Valider un constituant du système c’est s’assurer qu’il est conforme aux exigences
                imposées par le niveau supérieur. <mediaobject>
                    <alt>Composants validés</alt>
                    <imageobject>
                        <imagedata fileref="images/04_Validation.png"/>
                    </imageobject>
                </mediaobject>
            </para>
            <para>Valider un système c’est s’assurer qu’il fonctionne comme attendu par le client
                dans son environnement opérationnel.</para>
            <note>
                <para>Dans certains projets informatiques, la validation d'un système peut être
                    associée à la notion de VABF : "Validation d'Aptitude au Bon
                    Fonctionnement"</para>
            </note>
        </section>
        <section role="slide" xml:id="ivvq_s8">
            <title>L'intégration</title>
            <blockquote><attribution><link
                xlink:href="http://www.afis.fr/nm-is/Pages/de%20l%27int%C3%A9gration%20%C3%A0%20la%20qualification.aspx"
                >AFIS</link>.</attribution>
                <para> L’intégration est une opération systématique, réalisée en conformité à un plan
                d’intégration préétabli, d’assemblages successifs de composants dûment vérifiés et
                validés, en faisant à chaque pas les tests d’intégration et de non-régression
                planifiés, ainsi que, lors de l’obtention d’un constituant, sa vérification par
                rapport à ses exigences techniques et sa validation par rapport à ses exigences
                allouées par le niveau supérieur. In fine le système ainsi intégré est vérifié par
                rapport aux exigences système et validé par rapport à ses exigences initiales.
            </para></blockquote>
        </section>
        <section role="slide" xml:id="ivvq_s9">
            <title>La qualification</title>
            <blockquote>
                <attribution><link
                    xlink:href="http://www.afis.fr/nm-is/Pages/de%20l%27int%C3%A9gration%20%C3%A0%20la%20qualification.aspx"
                    >AFIS</link>.</attribution>
                <para> Dans le cas d’un système unique, l’intégration correspond à la réalisation. Le
                système est alors intégré dans son environnement d’exploitation et de maintenance.
                Sa qualification opérationnelle est prononcée après vérification de son aptitude
                opérationnelle (incluant la vérification d’aptitude de son système de soutien),
                autorisant ainsi sa mise en exploitation. </para></blockquote>
            <note>
                <para>Dans certains projets informatiques, la qualification opérationnelle d'un
                    système peut être associée à la notion de VSR : "Vérification en Service
                    Régulier"</para>
            </note>
        </section>
        <section role="slide" xml:id="ivvq_s10">
            <title>Dans le contexte du développement de logiciel complexe</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Moyens pour vérifier chaque constituant du logiciel</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>Compilation</para>
                                </listitem>
                                <listitem>
                                    <para>Test unitaires</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Moyens pour valider chaque constituant</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>Tests d'intégration</para>
                                </listitem>
                                <listitem>
                                    <para>Tests fonctionnels</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Moyens pour gérer l'intégration</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>Plateforme d'intégration continue</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
    <section>
        <title>02 - Vérification et compilation</title>
        <section role="slide" xml:id="ivvq_s11">
            <title>Un petit programme en Groovy 2.x</title>
            <para>
                <literallayout class="monospaced" linenumbering="numbered" language="groovy" > 
                    @groovy.transform.ToString 
                    class Voiture { 
                        Integer nbPorte = 3 
                        String couleur
                    } 
                     
                    def test() { 
                        new Voiture(couleur:15) 
                    } 
                    
                    test()
                </literallayout>
            </para>
            <para>Le programme affiche le résultat suivant...</para>
            <para>
                <computeroutput> Voiture(3,15) </computeroutput>
            </para>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    Groovy est un langage à typage dynamique : le contrôle de la cohérence de type ne s'effectue pas 
                    à la compilation. Le programme à l'exécution va tenter le cast de l'objet affecter dans le type
                    attendu. Si le cast est possible, le programme s'exécute avec succès.
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s12">
            <title>Un autre petit programme en Groovy 2.x</title>
            <para>
                <literallayout class="monospaced" linenumbering="numbered" language="groovy" > 
                    @groovy.transform.ToString 
                    class Voiture { 
                        Integer nbPorte = 3 
                        String couleur
                    } 
                    
                    @groovy.transform.TypeChecked 
                    def test() { 
                        new Voiture(couleur:15) 
                    } 
                    
                    test()
                </literallayout>
            </para>
            <para>Le résultat obtenu est une erreur de compilation...</para>
            <para>
                <computeroutput> 1 compilation error: [Static type checking] - Cannot assign value
                    of type int to variable of type java.lang.String at line: 9, column: 24
                </computeroutput>
            </para>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    Groovy depuis la version 2 permet d'activer le "type checking" à la compilation.
                    Le langage se comporte donc à la demande comme un langage à typage statique où la
                    cohérence de type est vérifiée dès la compilation. Une incohérence détectée provoque 
                    alors une erreur de compilation.
                </para>
                <para>
                    Cette fonctionnalité récente de Groovy permet d'illustrer très simplement la différence
                    entre une approche dynamique et une approche statique.
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s13">
            <title>Compilation et vérification</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Premier niveau de vérification de conformité technique</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>Vérification qu'une implémentation d'interface est
                                        conforme au contrat</para>
                                </listitem>
                                <listitem>
                                    <para>Vérification de la cohérénce de type</para>
                                </listitem>
                                <listitem>
                                    <para>...</para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem>
                        <para>Vérification plus ou moins stricte</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>Dépend du langage</para>
                                </listitem>
                                <listitem>
                                    <para>Typage statique vs typage dynamique</para>
                                </listitem>
                                <listitem>
                                    <para>Typage faible vs typage fort</para>
                                </listitem>
                                <listitem>
                                    <para>...</para>
                                </listitem>
                                <listitem>
                                    <para>
                                        <link xlink:href="http://en.wikipedia.org/wiki/Type_system"
                                            >http://en.wikipedia.org/wiki/Type_system</link>
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s14">
            <title>Articles à lire</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><link xlink:href="http://martinfowler.com/bliki/DynamicTyping.html">Martin Fowler sur dynamic vs static typing</link></para>
                    </listitem>
                    <listitem>
                        <para><link xlink:href="http://www.artima.com/weblogs/viewpost.jsp?thread=328540">Bruce Eckel sur Scala</link></para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
    <section>
        <title>03 - Vérifications et tests unitaires</title>
        <section role="slide" xml:id="ivvq_s15">
            <title>Qu'est ce qu'un test unitaire ?</title>
            <para>Un test unitaire est le test d'une unité de code en isolation.</para>
            <para>
                <itemizedlist>
                    <listitem>
                            <para>"Unité" - Plus petite partie du code que l'on peut tester en isolation</para>
                    </listitem>
                    <listitem>
                            <para>"En isolation" - Séparé de toute autre partie du logiciel, de toute autre unité de code</para>
                    </listitem>
                    <listitem>
                        <para>L’environnement opérationnel est simulé si nécessaire par des «faux» objets (mocked objects, stubs)</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s16">
            <title>Caractéristiques cibles pour une unité de code</title>
            <para>
                <itemizedlist>
                    <listitem><para>Unité de compilation reconnue par le compilateur</para></listitem>
                    <listitem><para>Occupe un seul fichier</para></listitem>
                    <listitem><para>Nombre de lignes de code peu élevé</para></listitem>
                    <listitem><para>Atomique : ne devrait pas est "découpable" en d'autres unité</para></listitem>
                </itemizedlist>
            </para>
            <note>
                <para>En programmation orientée objet, une unité de code est en général une classe.</para>
            </note>
        </section>
        <section role="slide" xml:id="ivvq_s17">
            <title>Outils pour les tests unitaires</title>
            <para>
                <itemizedlist>
                    <listitem><para>Outils pour l’écriture et l’exécution de tests</para>
                        <para>
                            <itemizedlist>
                                <listitem><para><link xlink:href="http://www.junit.org/">JUnit</link></para></listitem>
                                <listitem><para><link xlink:href="http://code.google.com/p/spock//">Spock</link></para></listitem>
                                <listitem><para>...</para></listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem><para>Outils pour dédiés à la création de mock objects</para>
                        <para>
                            <itemizedlist>
                                <listitem><para><link xlink:href="http://jmock.org/">JMock</link></para></listitem>
                                <listitem><para><link xlink:href="http://code.google.com/p/mockito/">Mockito</link></para></listitem>
                                <listitem><para>...</para></listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        <section role="slide" xml:id="ivvq_s18">
            <title>Focus sur Spock</title>
                <blockquote> 
                    <attribution>Extrait du site de Spock</attribution>
                    <para>Spock is a testing and specification framework for Java and Groovy
                    applications. What makes it stand out from the crowd is its beautiful and highly
                    expressive specification language. Thanks to its JUnit runner, Spock is
                    compatible with most IDEs, build tools, and continuous integration servers.
                    Spock is inspired from JUnit, jMock, RSpec, Groovy, Scala, Vulcans, and other
                    fascinating life forms.</para>
                </blockquote>
        </section>
        <section role="slide" xml:id="ivvq_s19">
            <title>
                Un premier exemple
            </title>
            <para>
            <link role="gist" xlink:href="https://gist.github.com/4066800">PionSpecification.groovy</link>
            </para>
            <section role="slideExcluded">
                <title>PionSpecification.groovy</title>
                <literallayout class="monospaced">
package chess

import spock.lang.Specification

class PionSpecification extends Specification{

   def "deplacement du pion"() {

     expect:
      new Pion(positionHorizontale: "a", positionVerticale: 2, 
               pieceCouleur: PieceCouleur.BLANC).bouge(0,3) == false
      new Pion(positionHorizontale: "a", positionVerticale: 2, 
               pieceCouleur: PieceCouleur.BLANC).bouge(0,2) == true
      new Pion(positionHorizontale: "a", positionVerticale: 3, 
               pieceCouleur: PieceCouleur.BLANC).bouge(0,2) == false
      new Pion(positionHorizontale: "a", positionVerticale: 3, 
               pieceCouleur: PieceCouleur.BLANC).bouge(0,1) == true

   }

}
                </literallayout>
            </section>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    Les exemples présentés visent à tester le projet <link xlink:href="https://github.com/FranckSilvestre/ChessSpockTests">ChessSpockTests</link> disponible sur Github. 
                </para>
                <para>
                    La syntaxe proposée par Spock est une syntaxe qui permet d'exprimer les tests 
                    sous forme de spécification du comportement attendu par l'objet testé.
                    Spock est un outil permettant de se rapprocher des démarches de "Behavior Driven Developpment".
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s20">
            <title>Le "Data Driven" test facilité</title>
            <para>
                <link role="gist" xlink:href="https://gist.github.com/4070999">PionSpecification2.groovy</link> 
            </para>
            <section role="slideExcluded">
                <title>PionSpecification2.groovy</title>
                <literallayout class="monospaced">
package chess

import spock.lang.Specification
import spock.lang.Unroll
import static chess.PieceCouleur.BLANC
import static chess.PieceCouleur.NOIR

class PionSpecification2 extends Specification {

  @Unroll
  def "deplacement du pion"() {

    expect:
    new Pion(positionHorizontale: posHor, 
             positionVerticale: posVer, pieceCouleur: couleur).bouge(depHor, depVer) == depCorrect

    where:
    couleur | posHor | posVer | depHor | depVer | depCorrect
    BLANC   | "a"    | 2      | 0      | 3      | false
    BLANC   | "a"    | 2      | 0      | 2      | true
    BLANC   | "a"    | 3      | 0      | 2      | false
    BLANC   | "a"    | 3      | 0      | 1      | true
    BLANC   | "a"    | 3      | 0      | -1     | false
    NOIR    | "a"    | 7      | 0      | -1     | true
    NOIR    | "a"    | 7      | 0      | 1      | false

  }

}
                </literallayout>
            </section>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                Il existe d'autres manières de faire du "data driven" test avec Spock.
                Il est notamment possible d'alimenter les paramètres à partir d'une requête SQL.
                Consulter la documentation Spock pour les détails techniques :
                    <link xlink:href="http://code.google.com/p/spock/wiki/Parameterizations">Spock parameterizations</link>
                </para>
                <para>
                    L'annotation @Unroll permet de lister séparement les itérations d'un data driven test dans les 
                    rapports de test et les runners.
                </para>
                <para>
                    Dans les deux exemples précédents, le bloc "expect" encapsule à la fois la partie qui modifie l'état de l'objet 
                    à tester et la partie réponse attendue. Dans la terminologie Spock, le bloc "expect" permet d'encapsuler le "stimulus" 
                    et la "réponse" attendue.
                </para>
                <para>
                    Très souvent, pour avoir un test plus profond, il est nécessaire de séparer clairement la partie "stimulus" de la
                    partie "réponse". Spock permet cette séparation par l'utilisation de deux blocs disctincts "when" et "then" 
                    représentant respectivement la description du stimulus ou des stimuli et la celle de la réponse attendue.
                </para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s21">
            <title>Séparation Stimuli / Réponse attendue</title>
            <para>
                <link role="gist" xlink:href="https://gist.github.com/4071051">PionSpecification3.groovy</link>  
            </para>
            <section role="slideExcluded">
                <title>PionSpecification3.groovy</title>
                <literallayout class="monospaced">
package chess

import spock.lang.Specification
import spock.lang.Unroll
import static chess.PieceCouleur.BLANC
import static chess.PieceCouleur.NOIR

class PionSpecification3 extends Specification {

  @Unroll
  def "deplacement du pion"() {

    setup:
    def pion = new Pion(positionHorizontale: posHor, positionVerticale: posVer, pieceCouleur: couleur)

    when:
    def depOk = pion.bouge(depHor, depVer)

    then:
    depOk == depCorrect
    if (depOk) {
      pion.positionHorizontale == ((int)posHor)+depHor
      pion.positionVerticale == posVer+depVer
    }

    where:
    couleur | posHor | posVer | depHor | depVer | depCorrect
    BLANC   | "a"    | 2      | 0      | 3      | false
    BLANC   | "a"    | 2      | 0      | 2      | true
    BLANC   | "a"    | 3      | 0      | 2      | false
    BLANC   | "a"    | 3      | 0      | 1      | true
    BLANC   | "a"    | 3      | 0      | -1     | false
    NOIR    | "a"    | 7      | 0      | -1     | true
    NOIR    | "a"    | 7      | 0      | 1      | false

  }

}                    
                </literallayout>
            </section>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    Le bloc "setup" permet de mettre en place la "fixture" i.e. initialiser les conditions de réalisation
                    du test (création, d'objets,...). Le bloc "setup" est appelé à chaque itération jouée.
                </para>
                <para>Un exemple un peu plus complet : <link xlink:href="https://github.com/FranckSilvestre/ChessSpockTests/blob/master/src/test/groovy/chess/EchiquierSpecification.groovy">EchiquierSpecification.groovy</link></para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s22">
            <title>Exemple de test d'interaction </title>
            <para>
                <link role="gist" xlink:href="https://gist.github.com/4071389">EchiquierSpecification2.groovy</link>  
            </para>
            <section role="slideExcluded">
                <title>EchiquierSpecification2.groovy</title>
                <literallayout class="monospaced">
package chess

import spock.lang.Specification
import static chess.PieceCouleur.BLANC
import static chess.PieceCouleur.NOIR

class EchiquierSpecification2 extends Specification {

  Echiquier echiquier = new Echiquier()
  IPiece piece = Mock()

  def "Interaction echiquier piece"() {

    when:
    echiquier.deplacePiece(piece, 0,1)

    then:
    1*piece.bouge(0,1)
    _ * _

  }
}                    
                </literallayout>
            </section>
            <section role="comments">
                <title>Commentaires</title>
                <para>
                    L'approche "Interaction based testing" s'intéresse plus à l'interaction entre les objets
                    qu'à l'état des objets.Cette approche permet de tester que la collaboration entre les objets 
                    s'effectue comme attendue.
                </para>
                <para>
                    L'utilisation d'objets "proxy" est nécessaire à Spock pour qu'il puisse intercepter les messages reçus 
                    sur les objets visés par les tests. Ces proxy sont des objets de type Mock ou de type Stub. Les objets de
                    type Stub permettent de spécifier des réponses attendues lors de l'envoie d'un message sur un Stub.
                </para>
                <para>Pour aller plus loin, consultez la documentantion officielle de Spock sur <link xlink:href="http://docs.spockframework.org/en/latest/interaction_based_testing.html">l'Interaction based testing</link>.</para>
            </section>
        </section>
        <section role="slide" xml:id="ivvq_s23">
            <title>Approfondir...</title>
            <para>
                <itemizedlist>
                    <listitem><para>L'introduction officielle <link xlink:href="http://code.google.com/p/spock/wiki/SpockBasics">SpockBasics</link></para></listitem>
                    <listitem><para><link xlink:href="http://docs.spockframework.org/en/latest/">La documentation en ligne officielle</link></para></listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
</article>
